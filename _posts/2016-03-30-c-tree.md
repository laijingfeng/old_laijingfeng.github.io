---
layout: post
title: C Tree
date: 2016-03-30 00:00:00
categories: Code
excerpt : C Tree
---

* content
{:toc}

## Tree

```c
#include<stdio.h>

class Tree{
	
public:

	typedef struct Node{
		int value;
		Node * left, * right;
	}Node, * NODE;

	enum PrintType{
		Pre = 0,
		In,
		Pos,
	};

private:
	
	NODE root;
	int * data;
	bool isNowSearchTree;
	
	void CreateTree(NODE * node){
		data++;
		
		if((*data) == 0){
			(*node) = NULL;
			return ;
		}
		
		(*node) = new Node();
		(*node)->value = *(data);
		
		CreateTree(&((*node)->left));
		CreateTree(&((*node)->right));
	}
	
	void Insert(NODE * node, int val){
		if((*node) == NULL){
			(*node) = new Node();
			(*node)->value = val;
			(*node)->left = NULL;
			(*node)->right = NULL;
			return;
		}
		if(val < (*node)->value){
			Insert(&((*node)->left), val);
		}
		else if(val > (*node)->value){
			Insert(&((*node)->right), val);
		}
		else{
			printf("error: search tree can not have two node with one value\n");
		}
	}
	
	void Delete(NODE * node){
		if((*node) == NULL){
			return;
		}
		Delete(&((*node)->left));
		Delete(&((*node)->right));
		delete (*node);
		(*node) = NULL;
	}
	
	void PrintPreOrder(NODE * node){
		if((*node) == NULL){
			return;
		}
		printf("%d ", (*node)->value);
		PrintPreOrder(&((*node)->left));
		PrintPreOrder(&((*node)->right));
	}
	
	void PrintInOrder(NODE * node){
		if((*node) == NULL){
			return;
		}
		PrintInOrder(&((*node)->left));
		printf("%d ", (*node)->value);
		PrintInOrder(&((*node)->right));
	}
	
	void PrintPosOrder(NODE * node){
		if((*node) == NULL){
			return;
		}
		PrintPosOrder(&((*node)->left));
		PrintPosOrder(&((*node)->right));
		printf("%d ", (*node)->value);
	}

	int Leaf(Node * node){
		if(node == NULL){
			return 0;
		}
		if(node->left == NULL &&
			node->right == NULL){
			return 1;
		}
		return Leaf(node->left) + Leaf(node->right);
	}
	
public:
	
	Tree(){
		root = NULL;
	}
	
	~Tree(){
		Clear();
	}
	
	//搜索树输入以0结尾；其他树叶子的儿子标记为0的前序列
	void Create(int * arr, bool isSearchTree = false){
		if(arr == NULL){
			return ;
		}
		if(root != NULL){
			Clear();
		}
		data = arr - 1;
		isNowSearchTree = isSearchTree;
		if(isSearchTree){
			while((*(++data)) != 0){
				Insert(&root, *(data));
			}
		}
		else{
			CreateTree(&root);
		}
	}
	
	void InsertSearchTree(int val){
		if(root == NULL){
			isNowSearchTree = true;
		}
		else{
			if(isNowSearchTree == false){
				printf("error: now is not search tree, can not insert\n");
				return ;
			}
		}
		Insert(&root, val);
	}
	
	bool Empty(){
		return ((root == NULL) ? true : false);
	}
	
	void Clear(){
		Delete(&root);
	}

	int CountLeaf(){
		return Leaf(root);
	}
	
	void Print(PrintType type){
		if(root == NULL){
			printf("tree is null\n");
			return;
		}
		switch(type){
		case Pre:
			{
				PrintPreOrder(&root);
			}
			break;
		case In:
			{
				PrintInOrder(&root);
			}
			break;
		case Pos:
			{
				PrintPosOrder(&root);
			}
			break;
		}
		printf("\n");
	}
};

int main(){

	int nomarlTree[] = {1, 2, 3, 0, 0, 0, 4, 0, 0};
	int searchTree[] = {1, 4, 2, 5, 9, 6, 0};
	Tree * t = new Tree();
	
	t->Create(nomarlTree);
	t->Print(Tree::PrintType::Pre);
	printf("leaf = %d\n", t->CountLeaf());
	t->Clear();
	
	t->Create(searchTree, true);
	t->Print(Tree::PrintType::Pre);
	printf("leaf = %d\n", t->CountLeaf());
	t->Clear();
	
	return 0;
}
```

## 传值和传引用

```c
func1(T t){};//传值，新建一份
func2(T *t){};//传引用，直接引用

func1(t);
func2(&t);
```

因此，下面的是传值，`here`处node是NULL，若要能修改，`Test`的参数应该是`Node * *`类型。

```c
#include<stdio.h>
struct Node{
	int val;
};
void Test(Node * node){
	node = new Node();
	node.val = 1;
}
int main(){
	Node * node = NULL;
	Test(node);
	//here
	return 0;
}
```

这是为什么上面的树用到Node和NODE。




