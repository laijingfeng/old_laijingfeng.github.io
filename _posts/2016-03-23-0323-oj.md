---
layout: post
title: 0323_OJ
date: 2016-03-23 00:00:00
categories: Algorithm
excerpt : 0323_OJ
---

* content
{:toc}

## 2379

模拟

思路：

长度为len的数删除k个，就是保留m=len-k个。我们要找出最大的保留数num。

num长度为m，可以如下找到最优解：

num的第一位是在前len-(m-1)个数中挑一个最大的（有多个取左边的），

num的第二位是在前len-(m-2)个数中，第一位的数之后挑一个最大的（有多个取左边的），

...

## 1449

线段树

思路同2379，

数据量大了，O(n)寻找最大值总的复杂度是O(n^2)，要超时，

换成用线段树来找，维护一个线段树，功能是查询一个区间的偏左最大值和它的下标，总复杂度是n*log(n)。

## 2500

思考，排序

## 代码

### 2379

```c
#include<stdio.h>
#include<string.h>

#define N 10

struct NODE{
	int mx, mx_id;
};

char str[N];
int len_str;
int ans[N], len;

NODE findMax(int from, int to){
	int i;
	NODE ret;
	ret.mx = str[from] - '0';
	ret.mx_id = from;
	for(i = from + 1; i <= to; i++){
		if(str[i] - '0' > ret.mx){
			ret.mx = str[i] - '0';
			ret.mx_id = i;
		}
	}
	return ret;
}

int main(){
	int i, k;
	NODE find;
	while(scanf("%s%d", &str, &k)!=EOF){
		len_str = strlen(str);
		if(len_str <= k){
			printf("0\n");
			continue;
		}
		else if(k <= 0){
			printf("%s\n", str);
			continue;
		}
		len = 0;
		find.mx_id = -1;
		for(i = 0; i < len_str - k; i++){
			find = findMax(find.mx_id + 1, k + i);
			ans[len++] = find.mx;
		}
		for(i = 0; i < len; i++){
			printf("%d",ans[i]);
		}printf("\n");
	}
	return 0;
}
```

### 1449

```c
#include<stdio.h>
#include<string.h>

#define N 100005

struct NODE{
	int val, mx, mx_id;
};
NODE node[N << 2];
char arr[N];
int k, len_arr;
int ans[N], len;

void build(int le, int ri, int id){
	if(le == ri){
		node[id].val = arr[le - 1] - '0';
		node[id].mx = node[id].val;
		node[id].mx_id = le - 1;
		return;
	}

	int mid = (le + ri) >> 1;
	build(le, mid, id << 1);
	build(mid + 1, ri, (id << 1) | 1);

	int id_le = id << 1;
	int id_ri = (id << 1) | 1;
	if(node[id_le].mx >= node[id_ri].mx){
		node[id].mx = node[id_le].mx;
		node[id].mx_id = node[id_le].mx_id;
	}
	else{
		node[id].mx = node[id_ri].mx;
		node[id].mx_id = node[id_ri].mx_id;
	}
}

NODE findMax(int le, int ri, int id, int from, int to){
	if(from == le && to == ri){
		return node[id];
	}

	int mid = (le + ri) >> 1;
	if(to <= mid){
		return findMax(le, mid, id << 1, from, to);
	}
	else if(from > mid){
		return findMax(mid + 1, ri, (id << 1) | 1, from, to);
	}
	else{
		NODE val_le = findMax(le, mid, id << 1, from, mid);
		NODE val_ri = findMax(mid + 1, ri, (id << 1) | 1, mid + 1, to);

		return (val_le.mx >= val_ri.mx) ? val_le : val_ri;
	}
}

int main(){
	int i;
	NODE find;
	while(scanf("%s%d", &arr, &k) != EOF){
		len_arr = strlen(arr);
		if(len_arr <= k){
			printf("0\n");
			continue;
		}else if(k <= 0){
			printf("%s\n",arr);
			continue;
		}
		len = 0;
		build(1, len_arr, 1);
		find.mx_id = -1;
		for(i = 0; i < len_arr - k; i++){
			find = findMax(1, len_arr, 1, find.mx_id + 2, k + 1 + i);
			ans[len++] = find.mx;
		}
		for(i = 0; i < len; i++){
			printf("%d", ans[i]);
		}printf("\n");
	}
	return 0;
}
```

### 2500

```c
#include<stdio.h>
#include<algorithm>
using namespace std;

#define N 100005
typedef __int64 LL;

struct NODE{
	LL w,s;
};

NODE arr[N];
int n;

bool cmp(NODE a,NODE b){
	return (a.w + a.s) < (b.w + b.s);
}

int main(){
	int i;
	LL ans;
	while(scanf("%d",&n)!=EOF){
		for(i=0;i<n;i++){
			scanf("%I64d%I64d",&arr[i].w,&arr[i].s);
		}
		sort(arr,arr+n,cmp);
		ans = 0;
		for(i=1;i<n;i++){
			if(arr[i-1].w - arr[i].s > ans){
				ans = arr[i-1].w - arr[i].s;
			}
			arr[i].w += arr[i-1].w;
		}
		printf("%I64d\n",ans);
	}
	return 0;
}
```