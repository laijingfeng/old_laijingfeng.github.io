---
layout: post
title: 0323_OJ
date: 2016-03-23 00:00:00
categories: Algorithm
excerpt : 0323_OJ
---

* content
{:toc}

## 删除数字

长度为n(10^5)的数，删除k个数字，求剩余的最大值。

### 思路一

长度为n的数删除k个，就是保留m=n-k个。我们要找出最大的保留数num。

num长度为m，可以如下找到最优解：

num的第一位是在前n-(m-1)个数中挑一个偏左最大的，

num的第二位是在前n-(m-2)个数中，第一位的数之后挑一个偏左最大的，

...

num的第i位是在前n-(m-i)个数中，第(i-1)位的数之后挑一个偏左最大的。

用线段树求[x,n-(m-i)]之间的最大值和下标。

复杂度n*log(n)。

```c
#include<stdio.h>
#include<string.h>

#define N 100005

struct NODE{
	int val, mx, mx_id;
};
NODE node[N << 2];
char arr[N];
int k, len_arr;
int ans[N], len;

void build(int le, int ri, int id){
	if(le == ri){
		node[id].val = arr[le - 1] - '0';
		node[id].mx = node[id].val;
		node[id].mx_id = le - 1;
		return;
	}

	int mid = (le + ri) >> 1;
	build(le, mid, id << 1);
	build(mid + 1, ri, (id << 1) | 1);

	int id_le = id << 1;
	int id_ri = (id << 1) | 1;
	if(node[id_le].mx >= node[id_ri].mx){
		node[id].mx = node[id_le].mx;
		node[id].mx_id = node[id_le].mx_id;
	}
	else{
		node[id].mx = node[id_ri].mx;
		node[id].mx_id = node[id_ri].mx_id;
	}
}

NODE findMax(int le, int ri, int id, int from, int to){
	if(from == le && to == ri){
		return node[id];
	}

	int mid = (le + ri) >> 1;
	if(to <= mid){
		return findMax(le, mid, id << 1, from, to);
	}
	else if(from > mid){
		return findMax(mid + 1, ri, (id << 1) | 1, from, to);
	}
	else{
		NODE val_le = findMax(le, mid, id << 1, from, mid);
		NODE val_ri = findMax(mid + 1, ri, (id << 1) | 1, mid + 1, to);

		return (val_le.mx >= val_ri.mx) ? val_le : val_ri;
	}
}

int main(){
	int i;
	NODE find;
	while(scanf("%s%d", &arr, &k) != EOF){
		len_arr = strlen(arr);
		if(len_arr <= k){
			printf("0\n");
			continue;
		}else if(k <= 0){
			printf("%s\n",arr);
			continue;
		}
		len = 0;
		build(1, len_arr, 1);
		find.mx_id = -1;
		for(i = 0; i < len_arr - k; i++){
			find = findMax(1, len_arr, 1, find.mx_id + 2, k + 1 + i);
			ans[len++] = find.mx;
		}
		for(i = 0; i < len; i++){
			printf("%d", ans[i]);
		}printf("\n");
	}
	return 0;
}
```

### 思路二

要删除一个数字使得剩余最大，策略是：

如果有递增，则删除第一个递增的，没有则删除最后一个。

用链表来做。

复杂度O(n)。

```c
#include<stdio.h>
#include<string.h>

#define N 100005

struct NODE{
	int pre, next;
	char val;
};

NODE node[N];
char str[N];
int root, now;

void delOne(){
	if(node[now].pre == -1 && node[now].next == -1){//最后一个
		node[now].val = '0';
		return ;
	}
	while(true){
		if(node[now].next == -1){//尾巴
			now = node[now].pre;
			node[now].next = -1;
			break;
		}
		if(node[now].val < node[node[now].next].val){
			if(now == root){//头
				now = root = node[now].next;
				node[now].pre = -1;
			}
			else{//中间
				int tnow = now;
				now = node[tnow].pre;
				node[now].next = node[tnow].next;
				node[node[tnow].next].pre = now;
			}
			break;
		}
		else{
			now = node[now].next;
		}
	}
}

int main(){
	int len, k, i;
	while(scanf("%s%d", &str, &k) != EOF){
		len = strlen(str);
		for(i = 0; i < len; i++){
			node[i].val = str[i];
			node[i].pre = i - 1;
			node[i].next = i + 1;
		}
		node[len - 1].next = -1;
		root = now = 0;
		while(k--){
			delOne();
		}
		while(root != -1){
			printf("%c", node[root].val);
			root = node[root].next;
		}printf("\n");
	}
	return 0;
}
```

## 2500

思考，排序

```c
#include<stdio.h>
#include<algorithm>
using namespace std;

#define N 100005
typedef __int64 LL;

struct NODE{
	LL w,s;
};

NODE arr[N];
int n;

bool cmp(NODE a,NODE b){
	return (a.w + a.s) < (b.w + b.s);
}

int main(){
	int i;
	LL ans;
	while(scanf("%d",&n)!=EOF){
		for(i=0;i<n;i++){
			scanf("%I64d%I64d",&arr[i].w,&arr[i].s);
		}
		sort(arr,arr+n,cmp);
		ans = 0;
		for(i=1;i<n;i++){
			if(arr[i-1].w - arr[i].s > ans){
				ans = arr[i-1].w - arr[i].s;
			}
			arr[i].w += arr[i-1].w;
		}
		printf("%I64d\n",ans);
	}
	return 0;
}
```